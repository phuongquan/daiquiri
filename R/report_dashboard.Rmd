---
title: "EHRCHANGEPOINTS dashboard"
output: 
  flexdashboard::flex_dashboard
params:
  sourcedata: sourcedata
  aggregatedata: aggregatedata
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(rownames.print = FALSE)

# note: flex_dashboard says it requires shiny but it seems to work without it so avoid installing it if we can
```

Created on: `r Sys.time()`

Dataset: `r encodeString(params$sourcedata$sourcename)`

Source dataset
=======================================================

Column {.tabset}
-------------------------------------
```{r sourcedata}
#print(params$sourcedata)

sourcesummary <- summarise_source_data(params$sourcedata)

```

### Summary

```{r}
summarydf <- data.frame("Item" = c("Columns in source",
																	"Columns imported",
																	"Column used for timepoint",
																	"Min timepoint value",
																	"Max timepoint value",
																	"Rows in source",
																	"Duplicate rows",
																	"Rows missing timepoint values",
																	"Rows imported",
																	"Total validation warnings"),
												"Value" = c(sourcesummary$overall["cols_source_n"],
																		sourcesummary$overall["cols_imported_n"],
																		sourcesummary$overall["timepoint_fieldname"],
																		sourcesummary$overall["timepoint_min"],
																		sourcesummary$overall["timepoint_max"],
																		sourcesummary$overall["rows_source_n"],
																		sourcesummary$overall["rows_duplicates_n"],
																		sourcesummary$overall["timepoint_missing_n"],
																		sourcesummary$overall["rows_imported_n"],
																		nrow(sourcesummary$validation_warnings)),
												stringsAsFactors = FALSE
)
									 


reactable::reactable(summarydf,
					sortable = FALSE,
					filterable = FALSE,
					searchable = FALSE,
					pagination = FALSE,
					rownames = FALSE,
					striped = TRUE,
					compact = TRUE,
					fullWidth = FALSE,
					columns = list(
						Item = reactable::colDef(name = "",
													style = list(fontWeight = "bold"),
													minWidth = 300),
						Value = reactable::colDef(name = "",
													 minWidth = 200)
						)
					)

```


```{r}

sourcedatafields <- sourcesummary$datafields
sourcedatafields$ordinal_position <- seq.int(nrow(sourcedatafields))

```

### Columns ignored

```{r}

	reactable::reactable(sourcedatafields[which(sourcesummary$datafields$fieldtype == "ignore"), c("fieldname","fieldtype","ordinal_position")],
					sortable = TRUE,
					filterable = FALSE,
					searchable = FALSE,
					pagination = FALSE,
					rownames = FALSE,
					compact = TRUE,
					fullWidth = FALSE,
					columns = list(
						fieldname = reactable::colDef(name = "Column name",
															 minWidth = 200),
						fieldtype = reactable::colDef(name = "Field type",
															 minWidth = 100),
						ordinal_position = reactable::colDef(name = "Column position")
						)
					)
```

### Columns imported

```{r}

reactable::reactable(sourcedatafields[which(sourcesummary$datafields$fieldtype != "ignore"),],
				sortable = TRUE,
				filterable = FALSE,
				searchable = FALSE,
				rownames = FALSE,
				pagination = FALSE,
				striped = TRUE,
				highlight = TRUE,
				columns = list(
					fieldname = reactable::colDef(name = "Column name",
														 style = list(fontWeight = "bold")),
					fieldtype = reactable::colDef(name = "Field type"),
					datatype = reactable::colDef(name = "Datatype"),
					count = reactable::colDef(name = "Total values"),
					missing = reactable::colDef(name = "Missing values"),
					min = reactable::colDef(name = "Min value"),
					max = reactable::colDef(name = "Max value"),
					validation_warnings = reactable::colDef(name = "Validation warnings"),
					ordinal_position = reactable::colDef(name = "Column position")
					)
				)
```


### Validation warnings

```{r}

if (nrow(sourcesummary$validation_warnings) > 0){
	reactable::reactable(sourcesummary$validation_warnings,
					sortable = TRUE,
					filterable = FALSE,
					searchable = FALSE,
					rownames = FALSE,
					pagination = FALSE,
					striped = TRUE,
					highlight = TRUE,
					compact = TRUE,
					fullWidth = FALSE,
					columns = list(
						Datafield = reactable::colDef(name = "Column name",
															 style = list(fontWeight = "bold"),
															 minWidth = 200),
						rowindex = reactable::colDef(name = "Row position"),
						message = reactable::colDef(name = "Details",
														 minWidth = 500)
						)
					)
} else{
	print("None")
}

```

Aggregated data
=======================================================

Column {.tabset}
-------------------------------------

### Summary

```{r aggregatedata}
aggsummary <- summarise_aggregated_data(params$aggregatedata)

aggsummarydf <- data.frame("Item" = c("Column used for timepoint",
																			"Min timepoint value",
																			"Max timepoint value",
																			"Timepoint aggregation unit",
																			"Total number of timepoints",
																			"Number of empty timepoints",
																			"Number of data fields",
																			"Column(s) used as partitionfield"),
													 "Value" = c(aggsummary$overall["timepoint_fieldname"],
													 						aggsummary$overall["timepoint_min"],
													 						aggsummary$overall["timepoint_max"],
													 						aggsummary$overall["aggregation_timeunit"],
													 						aggsummary$overall["n_timepoints"],
													 						aggsummary$overall["n_empty_timepoints"],
													 						aggsummary$overall["n_fields"],
													 						aggsummary$overall["partitionfield_fieldnames"]),
													 stringsAsFactors = FALSE
)

reactable::reactable(aggsummarydf,
					sortable = FALSE,
					filterable = FALSE,
					searchable = FALSE,
					pagination = FALSE,
					rownames = FALSE,
					striped = TRUE,
					compact = TRUE,
					fullWidth = FALSE,
					columns = list(
						Item = reactable::colDef(name = "",
													style = list(fontWeight = "bold"),
													minWidth = 300),
						Value = reactable::colDef(name = "",
													 minWidth = 200)
						)
					)

```


```{r}
timepointcolname <- names(params$aggregatedata$aggregatefields[[1]]$values)[1]

# TODO: is it better to do this once for all overview aggtypes then subset later when plotting?
overview_data <- function(aggfields, aggtype){
#	aggfields = testcpddata_byday$aggregatefields

	data <- data.table::data.table()
	for(i in seq_along(names(aggfields))){
		f <- names(aggfields)[i]
		if( aggtype %in% names(aggfields[[f]]$values) ){
			d <- aggfields[[f]]$values[, c(timepointcolname, aggtype), with = FALSE]
			d[, fieldname := f]
		} else{
			d <- aggfields[[f]]$values[, timepointcolname, with = FALSE]
			d[, fieldname := f]
			d[, (aggtype) := NA]
		}
		data <- rbind(data, d)
	}
	data[, fieldname := factor(fieldname, levels = names(aggfields))]
	
	# # only return the fields that have the aggtype
	# data <- data.table::data.table()
	# for(i in seq_along(names(aggfields))){
	# 	f <- names(aggfields)[i]
	# 	if( aggtype %in% names(aggfields[[f]]$values) ){
	# 		d <- aggfields[[f]]$values[, c(timepointcolname, aggtype), with = FALSE]
	# 		d[, "fieldname" := f]
	# 		data <- rbind(data, d)			
	# 	}
	# }
	# data
		
	# old way returns warnings because allfieldscombined is numeric type vs ints for everything else		
	# data <- data.table::data.table(aggfields[[1]]$values[, 1])
	# for(i in seq_along(names(aggfields))){
	# 	f <- names(aggfields)[i]
	# 	if( aggtype %in% names(aggfields[[f]]$values) ){
	# 		data[, (f) := aggfields[[f]]$values[, aggtype, with = FALSE]]
	# 	}
	# }
	# data <- data.table::melt(data, id.vars = names(aggfields[[1]]$values)[1], variable.name = "fieldname", value.name = aggtype)
}



overview_lineplot <- function(data, timepointcol, valuecol, fillcolour = NA, title = NULL){
	ggplot2::ggplot(data, ggplot2::aes_string(timepointcol, valuecol)) +
    ggplot2::geom_line() +
    ggplot2::scale_y_continuous(labels = scales::label_comma(), limits = c(0, NA)) +
    ggplot2::scale_x_date(#breaks = breaks_pretty(), 
      breaks = "1 year", labels = scales::date_format("%Y"), 
      expand = c(0,0)) +
    ggplot2::labs(y = NULL, x = NULL, title = title) +
    ggplot2::theme_bw() +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.35, hjust = 1, size = 7),
          axis.text.y = ggplot2::element_text(size = 7),
          axis.title = ggplot2::element_text(size = 8),
		      plot.title = ggplot2::element_text(size=8, face = "bold", hjust = 0.5),
          plot.background = ggplot2::element_rect(color = "black")) +
		# use ribbon instead of area so that NAs don't get interpolated
    ggplot2::geom_ribbon(data = data[!is.na(get(valuecol)), ymin := 0], ggplot2::aes_string(x = timepointcol, ymin = "ymin", ymax = valuecol), fill = fillcolour, alpha = 0.5)
}
 
# TODO: Decide whether or not to include the timepoint field in the heatmap
# TODO: is it better to include all datafields and putting in NAs if they don't have the nonconformant aggtype? Will make plots more consistent
overview_heatmap <- function(data, timepointcol, valuecol, fillcolour = "darkred"){
	ggplot2::ggplot(data, ggplot2::aes_string(timepointcol, "fieldname", fill = valuecol)) +
    ggplot2::geom_tile() +
    ggplot2::scale_fill_gradient("Instances", low="white", high = fillcolour, na.value = "grey",
                        labels=function(x) format(x, big.mark = ",", scientific = FALSE),
                        limits = c(0, NA)) +
    ggplot2::scale_x_date(#breaks = breaks_pretty(), 
      breaks = "1 year", labels = scales::date_format("%Y"), 
      expand = c(0,0)) +
    ggplot2::labs(y = "Instances per fieldname", x = NULL) +
    #facet by variable (field name) to create separate bars
    ggplot2::facet_grid(fieldname~., scales = "free", space = "free") +
    ggplot2::theme_bw() +
    ggplot2::theme(#remove grid lines
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      #remove facet labels and their background
      strip.background = ggplot2::element_blank(),
      strip.text.y = ggplot2::element_blank(),
      #add borders to the bars
      panel.border = ggplot2::element_rect(colour = "darkgrey", fill = NA, size = 0.75), 
      #remove space between facets
      panel.spacing = ggplot2::unit(0, "lines"),
      #remove y-axis ticks
      axis.ticks.y = ggplot2::element_blank(),
      axis.title = ggplot2::element_text(size = 8),
      axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.35, hjust = 1, size = 7),
      axis.text.y = ggplot2::element_text(size = 7),
      legend.position = "none",
      # legend.key.size = ggplot2::unit(0.32,"cm"),
      # legend.justification = "top",
      # legend.title = ggplot2::element_text(size = 8, face = "bold"),
      # legend.text = ggplot2::element_text(size=7),
      # legend.background = ggplot2::element_rect(colour = "black", size = 0.25),
      plot.background = ggplot2::element_rect(colour = "black"))
} 

```

### Data presence

```{r overview-presence}
#, fig.height = 0.5*as.numeric(aggsummary$overall["n_fields"])+3
aggtype <- "n"

data_presence <- overview_data(aggfields = params$aggregatedata$aggregatefields, aggtype)

lineplot_presence <- overview_lineplot(data = data_presence[fieldname == params$aggregatedata$timepoint_fieldname],
																			 timepointcol = timepointcolname,
																			 valuecol = aggtype,
																			 fillcolour = "pink",
																			 title = paste("Records per", params$aggregatedata$aggregation_timeunit))


# TODO: Decide whether or not to include the timepoint field in the heatmap
heatmap_presence <- overview_heatmap(data_presence[fieldname != "ALLFIELDSCOMBINED" & fieldname != "DUPLICATES"], 
																		 timepointcol = timepointcolname, 
																		 valuecol = aggtype, 
																		 fillcolour = "darkred")

cowplot::plot_grid(plotlist = list(lineplot_presence, heatmap_presence), ncol = 1, align = "v", axis = "lr", rel_heights = c(1,3))

```

### Missing values

```{r overview-missing}
aggtype <- "missing_n"

data_missing <- overview_data(aggfields = params$aggregatedata$aggregatefields, aggtype)

lineplot_missing <- overview_lineplot(data = data_missing[fieldname == "ALLFIELDSCOMBINED"],
																			 timepointcol = timepointcolname,
																			 valuecol = aggtype,
																			 fillcolour = "lightblue",
																			 title = paste("Total missing values per", params$aggregatedata$aggregation_timeunit))

heatmap_missing <- overview_heatmap(data_missing[fieldname != "ALLFIELDSCOMBINED" & fieldname != "DUPLICATES"], 
																		 timepointcol = timepointcolname, 
																		 valuecol = aggtype, 
																		 fillcolour = "darkblue")

cowplot::plot_grid(plotlist = list(lineplot_missing, heatmap_missing), ncol = 1, align = "v", axis = "lr", rel_heights = c(1,3))

```

### Non-conformant values

```{r overview-nonconformant}
aggtype <- "nonconformant_n"

data_nonconformant <- overview_data(aggfields = params$aggregatedata$aggregatefields, aggtype)

lineplot_nonconformant <- overview_lineplot(data = data_nonconformant[fieldname == "ALLFIELDSCOMBINED"],
																			 timepointcol = timepointcolname,
																			 valuecol = aggtype,
																			 fillcolour = "lightgreen",
																			 title = paste("Total nonconformant values per", params$aggregatedata$aggregation_timeunit))

heatmap_nonconformant <- overview_heatmap(data_nonconformant[fieldname != "ALLFIELDSCOMBINED" & fieldname != "DUPLICATES"], 
																		 timepointcol = timepointcolname, 
																		 valuecol = aggtype, 
																		 fillcolour = "darkgreen")

cowplot::plot_grid(plotlist = list(lineplot_nonconformant, heatmap_nonconformant), ncol = 1, align = "v", axis = "lr", rel_heights = c(1,3))

```

### Duplicate records

```{r overview-duplicates}
aggtype <- "sum"

data_duplicates <- overview_data(aggfields = params$aggregatedata$aggregatefields, aggtype)

lineplot_duplicates <- overview_lineplot(data = data_duplicates[fieldname == "DUPLICATES"],
																			 timepointcol = timepointcolname,
																			 valuecol = aggtype,
																			 fillcolour = "yellow",
																			 title = paste("Total duplicate records per", params$aggregatedata$aggregation_timeunit))

lineplot_duplicates

```

Per column
=======================================================

Column {.tabset}
-------------------------------------

```{r, results = 'asis'}
#params$aggregatedata <- testcpddata_byday
timepointcolname <-  names(params$aggregatedata$aggregatefields[[1]]$values)[1]
#aggtype <- "n"
for(i in seq_along(names(params$aggregatedata$aggregatefields))[1:2]){
  cat('\n###', names(params$aggregatedata$aggregatefields)[i], '\n')
	for(aggtype in params$aggregatedata$aggregatefields[[i]]$functionlist){
	  cat('\n####', aggtype, '\n')
	  p <- overview_lineplot(data = params$aggregatedata$aggregatefields[[i]]$values[, c(timepointcolname, aggtype), with = FALSE],
																				 timepointcol = timepointcolname,
																				 valuecol = aggtype
	  											 )
	  											 
	  print(p)
	  cat('\n')
	}
}
```
